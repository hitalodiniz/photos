'use server';

import { createSupabaseClientForCache } from '@/lib/supabase.server';
import { headers } from 'next/headers';
import { createInternalNotification } from './notification.service';
import { UAParser } from 'ua-parser-js';
import { Galeria } from '../types/galeria';

interface GaleriaEventPayload {
  galeria: Galeria;
  eventType: 'view' | 'lead' | 'download' | 'share';
  visitorId?: string;
  metadata?: any;
}

export async function emitGaleriaEvent({
  galeria,
  eventType,
  visitorId,
  metadata = {},
}: GaleriaEventPayload) {
  const supabase = await createSupabaseClientForCache();
  const headerList = await headers();
  const ua = headerList.get('user-agent') || '';

  const parser = new UAParser(ua);
  const deviceInfo = {
    os: parser.getOS().name,
    browser: parser.getBrowser().name,
    type: parser.getDevice().type || 'desktop',
  };

  if (!galeria) return;
  const galeriaId = galeria.id;

  const ip = headerList.get('x-forwarded-for')?.split(',')[0] || 'unknown';
  const trackId = visitorId || ip;

  // 2. GravaÃ§Ã£o de EstatÃ­stica (Sempre acontece para o relatÃ³rio)
  if (eventType === 'view') {
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000).toISOString();
    const { data: recent } = await supabase
      .from('tb_galeria_stats')
      .select('id')
      .eq('galeria_id', galeria.id)
      .eq('event_type', 'view')
      .eq('visitor_id', trackId)
      .gt('created_at', oneHourAgo)
      .limit(1);

    // Se jÃ¡ visualizou na Ãºltima hora, nÃ£o grava de novo nem notifica
    if (recent && recent.length > 0) return;
  }

  await supabase.from('tb_galeria_stats').insert([
    {
      galeria_id: galeria.id,
      event_type: eventType,
      visitor_id: trackId,
      device_info: deviceInfo,
      metadata: metadata,
    },
  ]);

  // 3. LÃ“GICA DE NOTIFICAÃ‡ÃƒO INTELIGENTE
  const userId = galeria.photographer_id;

  switch (eventType) {
    case 'view':
      /**
       * ðŸ’¡ REGRA DE OURO:
       * Se a galeria TEM LEADS ativado, NÃƒO notificamos a visualizaÃ§Ã£o aqui.
       * Pois sabemos que o evento 'lead' virÃ¡ em seguida e farÃ¡ a notificaÃ§Ã£o.
       * Se a galeria for ABERTA (leads_enabled = false), notificamos o acesso.
       */
      if (!galeria.leads_enabled) {
        await createInternalNotification({
          userId,
          title: 'ðŸ‘€ Novo Acesso',
          message: `Sua galeria aberta "${galeria.title}" estÃ¡ sendo visualizada agora.`,
          type: 'info',
          link: `/dashboard/galerias/${galeriaId}`,
        });
      }
      break;

    case 'lead':
      // Notifica sempre, pois Ã© a conversÃ£o real
      await createInternalNotification({
        userId,
        title: 'ðŸ‘¤ Visitante Identificado',
        message: `${metadata.nome || 'Um visitante'} acessou a galeria "${galeria.title}".`,
        type: 'success',
        link: `/dashboard/galerias/${galeriaId}/leads`,
      });
      break;

    case 'download':
      await createInternalNotification({
        userId,
        title: 'ðŸ“¥ Download Realizado',
        message: `Arquivos baixados na galeria "${galeria.title}".`,
        type: 'info',
        link: `/dashboard/galerias/${galeriaId}`,
      });
      break;
  }
}
